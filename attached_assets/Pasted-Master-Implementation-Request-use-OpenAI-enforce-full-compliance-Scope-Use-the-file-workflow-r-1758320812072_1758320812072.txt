Master Implementation Request (use OpenAI + enforce full compliance)

Scope:
Use the file workflow_reference.json as the single source of truth. Treat the current implementation as non-compliant unless it exactly matches the file. With the OpenAI integration already connected, have OpenAI read the file and generate the design, code, migrations, and tests to bring the system into full end-to-end compliance across Stages 1–10. Ask me only if something is truly ambiguous or blocked.

Global non-negotiables:

Do not rename schemas/fields/terms unless the spec explicitly requires it.

Enforce central FX from Settings (Stage 10) everywhere; no manual FX fields in operations; persist fx_rate_used historically on each ETB transaction.

Implement and enforce negative-balance prevention toggle for capital.

Protect linked entries: no deletion of any record that is referenced by another module; use reverse/reclass flows.

Implement period closing and require admin approval to reopen with audit reason.

Everything must be mobile-responsive (I will review on phone).

Provide migrations with rollbacks, clean diffs/PRs, and comprehensive tests.

Deliverables (for the whole project):

A Compliance Matrix (CSV/Markdown table) listing, for each stage: Required details (from the file), Current status, Gaps, How you fixed, Tests added.

DB migrations (+ rollback scripts) and code diffs/PRs with clear commit messages.

Unit + integration + E2E tests that prove all core invariants.

A concise CHANGELOG.md and a Testing Guide (how to verify in UI/API).

A one-page Mobile QA checklist covering key flows on small screens.

Stage-by-Stage Requirements (build/fix everything below)
Stage 1 — Working Capital

Build/Fix:

Ledger types: CapitalIn, CapitalOut, Reclass/Reverse, with Opening Balance optional (system must run with 0).

Auto ETB→USD conversion using central FX (Stage 10); persist fx_rate_used and original amounts.

Negative balance toggle: when ON, block any CapitalOut that would drop the balance below 0; when OFF, warn + require manager approval (sensitive policy).

Amount match: capital entry amount must exactly match the linked payment (after FX).

Link protections: no delete if linked to purchase/shipping/expense; use reverse entries.

Validations/Controls: amount=payment; FX enforced; negative guard; linked deletion lock.

Reports: live capital balance; movement statement with references; currency breakdown.

Tests: FX correctness, negative guard, amount-match, reverse/reclass flows, linked delete blocked.

Stage 2 — Purchases

Build/Fix:

Funding source field: From Capital vs External.

If From Capital → auto-create CapitalOut (Stage 1), with FX + audit link.

Advances allowed prior to final weight/price; settlement with supplier later (debit/credit) without breaking links.

Auto intake: every purchase line auto-appears in FIRST warehouse (Stage 3) “Purchases list.”

Immutable after linkage: once linked to filtering/shipping/sales, price/weight edits follow sensitive policy (once-only token/±%/approval).

Validations: FX enforced; funding source required; settlement math correct.

Tests: advance→settlement, auto CapitalOut, auto stock in FIRST, edit locks post-linkage.

Stage 3 — Warehouse

Build/Fix:

Two warehouses: FIRST (origin/prep) and FINAL (destination).

Stock line statuses: AWAITING_DECISION → READY_TO_SHIP / AWAITING_FILTER → (after filtering) NON_CLEAN or READY_TO_SHIP.

Filtering (full line): record input, outputs (clean/non-clean) with rule clean + nonclean ≤ input.

Cost redistribution: assign 100% of purchase cost to the clean portion only; non-clean cost = $0.

Tabs UI in FIRST: Purchases list / Awaiting Filter / Ready to Ship / Non-Clean, each with totals.

Packing/Prep: capture cartons/labels/wraps; auto-deduct supplies (Stage 5) and allocate packing cost to the order.

Reserved for shipping (optional qty_kg_reserved) when linked to a shipping leg.

Validations: no partial filtering split over time (single operation per line); no ship > available ready; no sell > available non-clean.

Tests: redistribution math, status guards, packing→consumption→cost allocation, reserve logic.

Stage 4 — Shipping

Build/Fix:

Multi-leg shipping: per leg store from/to country, planned/actual dates, carrier, weights (net_kg, carton_kg, gross_kg, chargeable_kg), carton count.

Pricing rule: if chargeable_kg present, use it as basis; else use gross_kg. Support rate ↔ total bidirectional calc.

Commission % on leg total (transfer fee) added to leg cost; if paid from capital/cash, create CapitalOut.

Funding source per leg and per arrival cost (Capital/External); enforce FX.

Confirm departure: immediately deduct net_kg from FIRST; lock leg to CONFIRMED_DEPARTURE.

Arrival costs: Broker/Handling/Delivery/Storage/Other; with FX + funding source.

Inspection on final arrival: input clean/damaged; rule clean + damaged = expected net; post → clean enters FINAL (READY_FOR_SALE), damaged → operating loss (no stock).

Landed cost calc: purchase cost on clean (from Stage 3) + total shipping (legs+arrival) + packing (Stage 5) spread over clean after inspection; compute 8kg/20kg carton cost.

Validations: edit restrictions after confirm; FX; consistency on weights and inspection totals.

Tests: leg math, commission, funding/CapitalOut, confirm-deduct, inspection split, landed cost per kg/carton.

UI prompts when adding a leg: from/to, dates (plan/actual), carrier, net/carton/gross/chargeable, carton count, rate or total (calc the other), funding source, currency (auto FX), commission %, confirm departure toggle.

Stage 5 — Operating Expenses (build the full module)

Build/Fix:

Supplies catalog: item_code, name (cartons/labels/wraps…), UOM, conversion factors.

SUPPLY_PURCHASE: increases supplies inventory; FX + funding (Capital/External). Creates CapitalOut if Capital.

SUPPLY_CONSUMPTION: never creates capital entry; triggered automatically from packing in Stage 3; deducts from supplies (FIFO or weighted avg) and allocates cost to order; compute packaging cost per carton.

LABOR and RENT: expenses with allocation rules (weighted by kg, by time, or manual) across orders; FX + funding; auto distribution entries.

Expense types: LABOR / RENT / SUPPLY_PURCHASE / SUPPLY_CONSUMPTION / OTHER.

Validations: no consumption > balance; conversion factors enforced; abnormal supply price warnings (±X%).

Tests: purchase→balance→consumption flow, allocation math, FX, CapitalOut rules.

Stage 6 — Sales

Build/Fix:

Source warehouse rules:

FINAL → clean only;

FIRST → non-clean only (local).

Default single-order invoice; optional multi-order split with explicit lines (order_id/unit/cartons).

Units: 8 kg and 20 kg cartons (only); auto kg = cartons × (8 or 20).

Pricing: price_per_carton ↔ total bidirectional; FX with fx_rate_used saved.

Returns: must go back to same order and same warehouse as original line; adjust inventory and revenue/A/R accordingly.

A/R & Receipts: multi-currency receipts with historical FX; optional customer credit limit alert.

COGS: for clean, use landed cost per kg/carton (from Stages 3–5); for non-clean, cost = $0.

Validations: source matching, stock availability, precise splits, return constraints, sensitive price change policy (Stage 8).

Tests: FINAL vs FIRST enforcement, split invoices, returns, multi-currency receipts, COGS/margin calculations.

Stage 7 — Revenues

Build/Fix:

Revenue Ledger entry types: CustomerReceipt, CustomerRefund, Withdrawal, ReinvestOut, TransferFee, Reclass/Reverse.

Maintain a separate withdrawable revenue balance: collections − refunds − withdrawals − reinvest − fees.

Withdrawals only from Revenues (never from Capital).

Reinvestment flow (Admin only):

In Revenues: ReinvestOut = −amount, TransferFee = −fee;

In Capital (Stage 1): CapitalIn = +amount;

In Expenses (Stage 5): record transfer/bank fee as operating expense.

All with historical FX fields.

Balance guard: block withdrawals/transfers exceeding available revenue balance.

Dedup guard for receipts (no double-posting the same bank ref/hash).

Reports: revenue vs accounting sales; withdrawable balance trend; withdrawals by partner; reinvest ratio.

Tests: ledger math, reinvest triplets, balance guard, receipt deduplication.

Stage 8 — Users & Permissions (RBAC + policies)

Build/Fix:

Multi-role per user (e.g., Purchasing + Warehouse).

Warehouse scoping: user sees/acts only on assigned warehouses.

Financial visibility toggles per user: supplier prices, landed costs, margins, capital balance.

Sensitive change policies:

Once-only edit token (e.g., price change once within N hours);

±% tolerance (e.g., ±5%) allowed without approval; above → approval required;

Always-requires-approval actions (e.g., change chargeable on a confirmed leg).

Audit log: who/when/what before/after/why for all sensitive actions.

Tests: multi-role + scoping, visibility toggles, once-only token expiry, ±% caps, approval flows.

Stage 9 — Reports & KPIs

Build/Fix:

Stage reports (1–8), Order summaries, Period summaries, Global summary.

KPIs: Capital Utilization %, Capital Turnover Days, % Funding from Capital, Filter Yield %, Avg Shipping $/kg, Margin %, DSO, % Non-Clean Sales, Reinvest %.

Reports: Funding mix (Capital vs External), Currency breakdown (ETB/USD + fx), Revenue vs Collections, Aging 30/60/90.

Export: PDF/CSV. All figures traceable to source entries.

Tests: snapshot tests for aggregations, cross-checks (e.g., collections reconcile to revenue ledger), currency breakdown correctness.

Stage 10 — Settings

Build/Fix:

Central exchange rate (ETB per 1 USD) with activation timestamp and notes; editing here never re-prices historical entries.

Prevent negative balance toggle for Stage 1.

Sales units: default 8 or 20 kg; only these units allowed in Sales.

Enable/disable non-clean sales (hides FIRST as a sales source when off).

Filtering alerts: damaged % threshold for inspections.

Reports/KPIs defaults: currency display (USD or USD+ETB), period granularity, dashboard KPI toggles.

Security: session timeout; lock after N failed attempts; global defaults for sensitive change policies; in-app/email notifications.

Numbering: per document type (prefix/year/separator/length/reset), uniqueness checks; annual reset option.

Draft→Publish for settings; Snapshots and Audit on changes; schedule FX activation if needed.

Tests: FX propagation to all stages, negative toggle behavior, numbering uniqueness/reset, settings drafts/snapshots.

Testing & Acceptance (Definition of Done)

All flows pass unit/integration/E2E tests, including FX, approvals, linked deletion locks, negative balance guard, warehouse source enforcement, reinvest triplets, and reports reconciliation.

Mobile-responsive verified for key screens (warehouse tabs, shipping leg form, sales invoice, receipts, revenues ledger, reports dashboards).

Compliance Matrix shows “Implemented” for each requirement, with links to tests/commits.

Provide CHANGELOG.md + Testing Guide with exact steps to validate each stage in the UI.

Process:
Proceed to implement everything above using OpenAI to read workflow_reference.json and generate code/migrations/tests. If you encounter a genuine blocker or ambiguity, pause and ask. Otherwise, complete the work and deliver the items listed.