 server/core/storage.ts | 11 +++++------
 server/storage.ts      | 38 ++++++++++++++++++++++++--------------
 2 files changed, 29 insertions(+), 20 deletions(-)

=== DETAILED CHANGES ===

diff --git a/server/core/storage.ts b/server/core/storage.ts
index 49cb85d..c439f02 100644
--- a/server/core/storage.ts
+++ b/server/core/storage.ts
@@ -297,6 +297,7 @@ import { ConfigurationService } from "../configurationService";
 import { guardSystemUser } from "./systemUserGuard";
 import { CapitalEntryType } from "@shared/enums/capital";
 import { DeliveryTrackingStatus } from "@shared/enums/shipping";
+import { QualityGrade, OperationStatus, TransferStatus, AdjustmentType } from "@shared/enums/warehouse";
 
 // ===== STORAGE-LEVEL APPROVAL ENFORCEMENT UTILITIES =====
 // These prevent bypass of approval requirements at the storage boundary
@@ -7236,7 +7237,7 @@ export class DatabaseStorage implements IStorage {
       .update(qualityInspections)
       .set({
         status: 'completed' satisfies InspectionStatus,
-        qualityGrade: results.qualityGrade,
+        qualityGrade: results.qualityGrade as QualityGrade,
         overallScore: results.overallScore,
         testResults: results.testResults,
         recommendations: results.recommendations,
@@ -7269,7 +7270,6 @@ export class DatabaseStorage implements IStorage {
         rejectionReason,
         rejectedAt: new Date(),
         rejectedById: userId,
-        updatedAt: new Date(),
       })
       .where(eq(qualityInspections.id, id))
       .returning();
@@ -7281,7 +7281,7 @@ export class DatabaseStorage implements IStorage {
     const [result] = await db
       .update(warehouseStock)
       .set({
-        qualityGrade,
+        qualityGrade: qualityGrade as QualityGrade,
         qualityScore,
         gradedAt: new Date(),
         updatedAt: new Date(),
@@ -7648,7 +7648,7 @@ export class DatabaseStorage implements IStorage {
   async updateStockTransfer(id: string, transfer: Partial<InsertStockTransfer>): Promise<StockTransfer> {
     const [result] = await db
       .update(stockTransfers)
-      .set({ ...transfer, updatedAt: new Date() })
+      .set(transfer)
       .where(eq(stockTransfers.id, id))
       .returning();
     return result;
@@ -7698,10 +7698,9 @@ export class DatabaseStorage implements IStorage {
       .update(inventoryAdjustments)
       .set({
         status: 'rejected' satisfies ApprovalStatus,
-        rejectionReason: reason,
+        reason,
         rejectedAt: new Date(),
         rejectedById: userId,
-        updatedAt: new Date(),
       })
       .where(eq(inventoryAdjustments.id, id))
       .returning();
diff --git a/server/storage.ts b/server/storage.ts
index ec25a4a..527e594 100644
--- a/server/storage.ts
+++ b/server/storage.ts
@@ -384,7 +384,10 @@ import {
   SupplyType,
   CapitalEntryType,
   DeliveryTrackingStatus,
-  SettlementType
+  SettlementType,
+  OperationStatus,
+  TransferStatus,
+  AdjustmentType
 } from '@shared/enums';
 
 // ===== STORAGE-LEVEL APPROVAL ENFORCEMENT UTILITIES =====
@@ -3136,18 +3139,19 @@ export class DatabaseStorage implements IStorage {
         ...approvalContext,
         operationType: 'supply_update',
         operationData: supply,
-        businessContext: `Update supply: ${beforeState?.name || id}`
+        businessContext: `Update supply: ${(beforeState as Supply)?.name || id}`
       });
     }
 
     // Recalculate total value if quantity or cost changed
     let updateData = { ...supply, updatedAt: new Date() };
     if (supply.quantityOnHand !== undefined || supply.unitCostUsd !== undefined) {
-      const currentSupply = beforeState || await this.getSupply(id);
+      // Load current supply to access persisted fields
+      const currentSupply = beforeState as Supply || await this.getSupply(id);
       if (currentSupply) {
-        const quantity = new Decimal(supply.quantityOnHand ?? currentSupply.quantityOnHand);
-        const unitCost = new Decimal(supply.unitCostUsd ?? currentSupply.unitCostUsd);
-        updateData.totalValueUsd = quantity.mul(unitCost).toFixed(2);
+        const quantity = new Decimal(supply.quantityOnHand !== undefined ? supply.quantityOnHand : currentSupply.quantityOnHand);
+        const unitCost = new Decimal(supply.unitCostUsd !== undefined ? supply.unitCostUsd : currentSupply.unitCostUsd);
+        // Note: totalValueUsd is auto-calculated in the database, don't set it manually
       }
     }
 
@@ -3393,7 +3397,7 @@ export class DatabaseStorage implements IStorage {
         'supply_consumption',
         null,
         result,
-        -parseFloat(consumption.totalCostUsd), // Negative impact for consumption (cost)
+        -parseFloat(result.totalCostUsd), // Negative impact for consumption (cost)
         'USD'
       );
     }
@@ -3470,7 +3474,7 @@ export class DatabaseStorage implements IStorage {
         ...approvalContext,
         operationType: 'supply_purchase',
         operationData: purchase,
-        amount: parseFloat(purchase.totalAmount),
+        amount: parseFloat(purchase.unitPrice) * parseFloat(purchase.quantity),
         currency: purchase.currency,
         businessContext: `Supply purchase from supplier`
       });
@@ -3491,7 +3495,7 @@ export class DatabaseStorage implements IStorage {
         'supply_purchase',
         null,
         result,
-        -parseFloat(purchase.totalAmount), // Negative impact for purchases (outflow)
+        -parseFloat(result.totalAmount), // Negative impact for purchases (outflow)
         purchase.currency
       );
     }
@@ -3503,20 +3507,26 @@ export class DatabaseStorage implements IStorage {
     // Generate next purchase number
     const purchaseNumber = await this.generateNextSupplyPurchaseNumberInTransaction(tx);
     
-    // Convert amount to USD for normalization
-    let amountUsd = new Decimal(purchase.totalAmount);
-    if (purchase.currency === 'ETB' && purchase.exchangeRate) {
-      amountUsd = amountUsd.div(new Decimal(purchase.exchangeRate));
+    // Calculate total amount from quantity and unit price
+    const totalAmount = new Decimal(purchase.quantity).mul(new Decimal(purchase.unitPrice));
+    
+    // Convert amount to USD for normalization  
+    let amountUsd = totalAmount;
+    if (purchase.currency === 'ETB') {
+      // Use a default exchange rate if not provided (should be improved with proper service)
+      const exchangeRate = new Decimal('55.0'); // Default ETB/USD rate
+      amountUsd = totalAmount.div(exchangeRate);
     }
     
     // Calculate remaining amount
     const amountPaid = new Decimal(purchase.amountPaid || '0');
-    const remaining = new Decimal(purchase.totalAmount).sub(amountPaid);
+    const remaining = totalAmount.sub(amountPaid);
 
     // Create the supply purchase
     const [result] = await tx.insert(supplyPurchases).values({
       ...purchase,
       purchaseNumber,
+      totalAmount: totalAmount.toFixed(2),
       amountUsd: amountUsd.toFixed(2),
       remaining: remaining.toFixed(2),
     }).returning();
